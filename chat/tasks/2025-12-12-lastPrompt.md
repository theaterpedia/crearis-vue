## What we have
We have a clear separation of alpha-system from the final implementation: 
- alpha: homeLayout.vue (user-onboarding) + Stepper-Experience of DashboardLayout (CRUD limited to project-owner, project-creator + project-members only if they get entitled as record-creators by project-owner or project-creator)
- alpha: homeLayout.vue will only receive minor upgrades until 1.0-release, will stay a simple and straightforward, mostly hardcoded implementation that rules out the most basic things of auth. Nobody will touch on DashboardLayout (on regular ways) without having passed minimum standards of the user-role on the system, every user will be clearly readable by the system, clear separation between: partners, participants and 'team'

And we have the 'final implementation' prepared. The fully designed dashboardLayout.vue as a UI-Framework for all internal work + the sysreg_config as a State-Entity-User-Roles-Framework-by-code that rules the full matrix of business-processes on a database-level and compresses it into simple bitmasks that are easily executable on the UI-Framework. It is all fully untouched while the core of the system is capable of running 'around' it. We will transition in two phases: Beta will implement the core (the events- and the images-worflow) and will further shape the project workflow. From beta towards 1.0 we will only fit some parts of the existing 'alpha' into this, make adaptions.

## What we need (simple definition)
(beta to 1.0): Is all the rest of the DashboardLayout.vue that is NOT on project-status 'NEW' and 'DEMO', that is NOT about 'user-onboarding'. It is the 2 main-phases of a project and of events: Real-tough preparation with a lot of interactions and then backoffice-workflows after 'publication'. With v0.5-core-focus on Odoo we fully have to work with 'workflows' and we designed the sysreg_config to have a full and simple spec for that.

## What is our architecture
We have a fully cleared architecture that follows two basic principles: 
1. we always first read 
2. from what we can read we understand which parts of it we can update, write or even manage

The listings (what we read) are provided via the clist-group of components with completely autonomous query-logic, since all capabilities, status, transitions and even entity-specific sub-forms of those relations are either pre-existent (via sysreg) or are read in via 3-4 integers on the entity-records that never are too heavy to load, never will 'bloat' the listings with redundant information
Typically the listings (like on dashboardlayout visually implemented already) are preconfigured by a ListHead-Component + they work on a route and against an api that is entity-specific or at least is clearly addressed towards a certain 'interface' (like agenda: being clearly date-and-time-driven data / like topic: being). It should be easy to implement straightforward query-params and route-fragements that make use of this -> to input the project-relation-config into the ListHead which provides clear props for the entity-listing on that route. This entity-listing brings in a per-item-configurable sysreg-related bitmasks that easily can be merged with the pre-existing sysreg_config-bitmasked rules and with medium upgrades to the clist-group components will result in deeply intelligent flags, overlays, badges, action-sheets that automatically are configured on rowItems, cardItems and tileItems and just provide the allowed actions out-of-the box

The logic and ui-representation of our data-flow in dashboardLayout.vue + how we deal with external data from odoo
- the typical logic-flow runs visually clear from left-top (ListHead) -> left-column (Listing) -> main-panel (main-column)
- the main-panel always only holds one entity (excluded from this rule: images, where we might have a browser on the main-panel)
- this kind of setup will not change at all even when we bring in detail-records from odoo: partly be odoo model-configuration, partly on the endpoints it will be translated into sysreg-compatible schema, everything referenced by xmlids so that UI and composables mostly don't need to care whether they work against odoo or the Crearis-db

## Where is the empty space in our architecture that needs to be created now
we left open a 'strategic gap', it consists of clear lines and borders, finalized code and design vs. fully unimplemented 'white-space' or overimplemented 'multiplexity'. 
- 'White-space' is: How will the sysreg_config be filled, how will it be translated into per-entity transition-composables, state-machines or whatever, what kind of components like the statusEditor will arise. 
- 'multiplexity' is (not sooo much complex, more: multiple options that seem to be ambiguous, simply need clarification, simplification): the completely ambiguous, miracolous question: how will the events-workflow be implemented -> we have a lot of concepts enabled, tested, multiple fully speced workflow-machines are prepared on odoo:
		- sessions vs. tracks
		- with or without template->instance-logic

## concrete examples
- we have things to solve like 'conference', 'course', 'multi-phase workshop' with a variety of actors and relations, the default always being exactly 'instructor' (typically one) and 'participants', but extendable in all directions (partner-relation brings in 'locations', 'parents' (of participants being 'children') and 'team')
- we might list content from 'related projects' in our 'agenda', being entitled to click on it, getting routed to  that projects dashboard, being titled to comment or even update there, simply because our project is granted some relations on that project and the clist-group-component we display on our dashboard (remember: clist is not bound to project-boundaries) is capable to wire up even this 'forwarded' relation
- The other thing is a monolithic component 'dashboardLayout' that clearly is designed to become the switch-hub that orchestrates everything and always only loads exactly one entity-item

## your action
This now is my final big prompt for you to finish our v0.4-sprint. You have a bunch tasks from here:
1. you read and remember the sysreg_config-overview at /home/persona/crearis/crearis-vue/docs/dev/sysreg/capabilities-howto.md, take the capabilitiesEditor.vue (/home/persona/crearis/crearis-vue/src/components/sysreg/CapabilitiesEditor.vue) into your context + understand how easy it is to bring in i18n if always clearly the display name and description are used to display text
2. you read through the ambiguity-analysis (/home/persona/crearis/crearis-vue/chat/tasks/2026-01-12-SPRINT-v05-Input-HARDCODED_CAPABILITIES_AUDIT.md) of the current system: where are we currently breaking/overwriting the sysreg_config. Where do we have all the points that need refactoring to fully follow the sysreg_config (do not care about the user-workflow here)
3. you create another analysis-document (save it to chat/tasks/2025-12-12-dashboardLayout-crucialpoints.md) that has the goal to find the crucial points where the dashboardLayout could be taken apart into multiple components, composables and utilities, then rerun that document and try to find priorities
4. then you think about the 5 existing components/component-groups we have: statusEditor.vue, post-Its (not yet fully in use, but see in here: /home/persona/crearis/crearis-vue/src/components/comments), tagFamilies (+ tagGroupeditor, see here: /home/persona/crearis/crearis-vue/src/components/sysreg/TagFamilies.vue, TagGroupEditor.vue), clist-group (pGallery, see in here: /home/persona/crearis/crearis-vue/src/components/page and here: /home/persona/crearis/crearis-vue/src/components/clist) and EditPanel.vue (with context basePanel.vue) being the reference-implementation for a dual-use Editor-Component (both in dashboardLayout -> main panel + postPage.vue, eventPage.vue -> a right side Drawer) -> write a report with 6 ideas how those components could be brought together in the context of dashboardLayout.vue (save it to chat/imagination/dashboardLayoutFillTheGaps.md)
5. then you check through the docs of the multiplexed events-implementation on the odoo-system at: /home/persona/crearis/crearis-vue/docs/odoo/entities/events.md,  /home/persona/crearis/crearis-vue/docs/odoo/api/sessions.md,  /home/persona/crearis/crearis-vue/docs/odoo/api/events.md
6. then you read through the sysreg-naming-convention again (/home/persona/crearis/crearis-vue/docs/devdocs/CAPABILITIES_NAMING_CONVENTION.md) and fully read the approx 100 entries that are already on that table (read db-info from env, go via sudo, db-name: crearis_admin_dev)
7. then you remember all three analysis-documents of step 3 - 6 and cross-check them with first entries on the sysreg_config and create a report you save to chat/imagination: What are 3 really different options on how to get the next sprint running: We want to kickoff the events-workflow: first entering from 'demo' to the much anticipated internal 'draft'->'confirmed'-procedures and then releasing events, having registrations, event-participants becoming posts-creators. This all cross-checked with one mighty view-component: the dashboardLayout against the sysreg_config. You play this like chess (the strategy you really know well): Do this 4 times (4 documents to save to chat/imagination): Envision 2-3 basic workflow-steps, give them german interaction-wording for Theaterp√§dagogik + let them base on one clearly distinguishable first principle. This principle you express through 10-15 example new sysreg_config-entries then run this through the whole dataflow to the point where you can spec-out new interesting components, visual designs of small examples and the naming of special steps